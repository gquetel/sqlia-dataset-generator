import configparser
from pathlib import Path
from subprocess import Popen
import pandas as pd
import urllib.parse
import urllib.request
import random

from ..sql_connector import SQLConnector
from ..config_parser import get_seed


class sqlmapGenerator:
    def __init__(
        self,
        config: configparser.ConfigParser,
        templates: pd.DataFrame,
        sqlconnector: SQLConnector,
        placeholders_dictionnaries_list: list,
        port: int,
    ):
        """Initialize data structures for payload generation."""

        self.templates = templates.to_dict("records")
        self.config = config
        self.port = port
        self.sqlc = sqlconnector
        # List of dictionnaries of values
        self.pdl = placeholders_dictionnaries_list

        self.seed = get_seed(self.config)
        self.generated_attacks = pd.DataFrame()
        self._scenario_id = 0

    def call_sqlmap_subprocess(self, command):
        retcode = Popen(command, shell=True).wait()

    def get_default_query_for_path(self, url) -> str:
        _ = urllib.request.urlopen(url).read()
        queries = self.sqlc.get_and_empty_sent_queries()
        # If any queries have been sent in the meantime, ignore those and retrieve last one.
        return queries[-1]

    def perform_attack(self, technique: tuple, template_info: dict):
        name_technique, settings_technique = technique
        default_settings = "-v 0 -D dataset --level=5 --risk=3  --skip='user-agent,referer,host' --batch --flush-session -u "
        db_name = template_info["ID"].split("-")[0]

        params = {}
        for i, param in enumerate(template_info["placeholders"]):
            random_param_value = random.choice(self.pdl[(db_name, param)])
            params[param] = random_param_value

        encoded_params = urllib.parse.urlencode(params)
        url = f"http://localhost:{self.port}/{template_info['ID']}?{encoded_params}"
        quoted_url = f'"{url}"'

        default_query = self.get_default_query_for_path(url=url)

        # Url is built. Invoke sqlmap.
        command = (
            "sqlmap " + settings_technique + default_settings + quoted_url
        )
        print(f">> Using command: {command}")
        self.call_sqlmap_subprocess(command=command)

        # Now collect all generated attack through sqlconnector
        full_queries = self.sqlc.get_and_empty_sent_queries()

        # Remove queries generated by GET to url. Those are legitimate queries.
        full_queries = list(filter(lambda a: a != default_query, full_queries))

        malicious_input = ["" for _ in range(len(full_queries))]
        atk_id = f"{name_technique}-{self._scenario_id}"
        template_id = template_info["ID"]
        desc = ""
        label = 1

        _df = pd.DataFrame(
            {
                "full_query": full_queries,
                "label": label,
                "query_template_id": template_id,
                "attack_payload": malicious_input,
                "attack_id": atk_id,
                "attack_technique": name_technique,
                "attack_desc": desc,
            }
        )
        self.generated_attacks = pd.concat([self.generated_attacks, _df])
        self._scenario_id += 1

    def generate_attacks(self):
        techniques = {
            "boolean": "--technique=B --users ",
            "error": "--technique=E --schema --users --tables --count ",
            "union": "--technique=U --all  ",
            "stacked": "--technique=S -f ",
            "time": "--technique=T  --current-user ",
            "inline": "--technique=Q --all ",
        }

        for template in self.templates:
            for i in techniques.items():
                # example of cache file: ./cache/airport-I1-union
                cache_filepath = f"./cache/{template['ID']}-{i[0]}"

                if Path(cache_filepath).is_file():
                    print(
                        f">> Found cached file for scenario {template['ID']}-{i[0]}"
                    )
                    self.generated_attacks = pd.read_csv(cache_filepath)
                    continue

                self.perform_attack(i, template)
                self.generated_attacks.to_csv(cache_filepath)

        # TODO: Supposedly, all non-unique queries right now are "reconnaissance" queries.

        return self.generated_attacks
