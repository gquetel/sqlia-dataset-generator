import configparser
from pathlib import Path
from subprocess import Popen
import pandas as pd
import urllib.parse
import urllib.request
import random

from ..sql_connector import SQLConnector
from ..config_parser import get_seed


class sqlmapGenerator:
    def __init__(
        self,
        config: configparser.ConfigParser,
        templates: pd.DataFrame,
        sqlconnector: SQLConnector,
        placeholders_dictionnaries_list: list,
        port: int,
    ):
        """Initialize data structures for payload generation."""

        self.templates = templates.to_dict("records")
        self.config = config
        self.port = port
        self.sqlc = sqlconnector
        # List of dictionnaries of values
        self.pdl = placeholders_dictionnaries_list

        self.seed = get_seed(self.config)
        self.generated_attacks = pd.DataFrame()
        self._scenario_id = 0

    def call_sqlmap_subprocess(self, command):
        retcode = Popen(command, shell=True).wait()

    def get_default_query_for_path(self, url) -> str:
        _ = urllib.request.urlopen(url).read()
        queries = self.sqlc.get_and_empty_sent_queries()
        # If any queries have been sent in the meantime, ignore those and retrieve last one.
        return queries[-1]

    def perform_attack(self, technique: tuple, template_info: dict):
        # Load all information to build the sqlmap command.
        name_technique, settings_technique = technique
        db_name = template_info["ID"].split("-")[0]
        params = {}
        for i, param in enumerate(template_info["placeholders"]):
            random_param_value = random.choice(self.pdl[(db_name, param)])
            params[param] = random_param_value

        encoded_params = urllib.parse.urlencode(params)
        url = f"http://localhost:{self.port}/{template_info['ID']}?{encoded_params}"
        quoted_url = f'"{url}"'
        default_query = self.get_default_query_for_path(url=url)

        # Url is built. Invoke sqlmap for recognition
        # For recognition we want to ignore previous sessions files but save
        # the current results for the next call to sqlmap.

        # Not working.
        # recon_settings = (
        #     f"-v 0 -D dataset --skip-waf --level=5 --risk=3 --flush-session --skip='user-agent,referer,host' "
        #     f'--batch --eval="import random; random.seed(2)" --fingerprint -u '
        # )
        # recon_command = "sqlmap " + recon_settings + quoted_url
        # print(f">> Using recon command: {recon_command}")
        # self.call_sqlmap_subprocess(command=recon_command)
        # full_recon_queries = self.sqlc.get_and_empty_sent_queries()
        default_settings = (
            f"-v 0 -D dataset --flush-session --skip-waf --level=5 --risk=3  --skip='user-agent,referer,host' "
            f'--batch --eval="import random; random.seed({self.seed})" -u '
        )
        command = "sqlmap " + settings_technique + default_settings + quoted_url

        print(f">> Using exploit command: {command}")
        self.call_sqlmap_subprocess(command=command)
        full_queries = self.sqlc.get_and_empty_sent_queries()

        # Remove queries generated by GET to url. Those are legitimate queries.
        full_queries = list(filter(lambda a: a != default_query, full_queries))

        malicious_input = ["" for _ in range(len(full_queries))]
        atk_id = f"{name_technique}-{self._scenario_id}"
        template_id = template_info["ID"]
        desc = ""
        label = 1

        _df = pd.DataFrame(
            {
                "full_query": full_queries,
                "label": label,
                "statement_type": template_info["statement_type"],
                "query_template_id": template_id,
                "attack_payload": malicious_input,
                "attack_id": atk_id,
                "attack_technique": name_technique,
                "attack_desc": desc,
            }
        )
        self.generated_attacks = pd.concat([self.generated_attacks, _df])
        self._scenario_id += 1

    def generate_attacks(self):
        techniques = {
            "boolean": "--technique=B --all ", # 49822it --all
            "error": "--technique=E --all ", # Fast to test ~7k queries --all
            "union": "--technique=U --all  ", # 30212 queries --all
            "stacked": "--technique=S --users --banner ",
            "time": "--technique=T --current-user ",
            "inline": "--technique=Q --all ",
        }

        Path("./cache/").mkdir(parents=True, exist_ok=True)
        Path("./sessions/").mkdir(parents=True, exist_ok=True)

        for template in self.templates:
            for i in techniques.items():
                # example of cache file: ./cache/airport-I1-union
                cache_filepath = f"./cache/{template['ID']}-{i[0]}"

                if Path(cache_filepath).is_file():
                    print(f">> Found cached file for scenario {template['ID']}-{i[0]}")
                    self.generated_attacks = pd.read_csv(cache_filepath)
                    continue
                self.perform_attack(i, template)
                self.generated_attacks.to_csv(cache_filepath)

        return self.generated_attacks
